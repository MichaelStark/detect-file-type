# detect-file-type

> Модуль для определения типа файла по сигнатурам

## Get started

```js
  var detect = require('detect-file-type');

  detect.fromFile('./image.jpg', function(err, result) {
    
    if (err) {
      return console.log(err);
    }
    
    console.log(result); // { ext: 'jpg', mime: 'image/jpeg' }
  });
```

## API

### fromFile(filePath, bufferLength, callback)
Определение типа файла находящегося на диске
- `filePath` - путь к файлу
- `bufferLength` - необязательный параметр. Размер буфера в байтах начиная с начала файла. По умолчания равен 100. В случае если размер файла менее 100 байт будет равен размеру файла.
- `callback`
 
### fromBuffer(buffer, callback)
Определение типа файла находящегося на диске
- `buffer` - uint8array
- `callback`

### addSignature(siganture)
Добавляет новую сигнатуру для определения файла к уже существующим сигнатурам
- `signature` - сигнатура. Читайте секцию о создании собственных сигнатур ниже.

## Сигнатуры и создание собственных сигнатур
Определение типа файла происходит благодаря сигнатурам.
Простейшая сигнатура в формате json выглядит следующим образом:
```json
{
  "type": "jpg",
  "ext": "jpg",
  "mime": "image/jpeg",
  "rules": [
    { "type": "equal", "start": 0, "end": 2, "bytes": "ffd8"  }
  ]
}
```
где:
- `type` - тип сигнатуры, в большинстве случаев равна полю `ext`
- `ext` - расширение файла
- `mime` - mime тип файла
- `rules` - список правил при помощи которых определяется тип файла

Рассмотрим более подробно поле `rules`:

**Данное поле должно является массивом объектов.**

- `type` - тип правила. Есть несколько типов правил: `equal`, `notEqual`, `contains`, `notContains`, `or`, `and`

Идущий далее набор полей зависит от типа правила. Разберем следующий правила: equal, notEqual, contains и notContains.

- `equal` - обязательно содержит поле `bytes`. Получает срез буфера начиная со `start` (равен 0 если не определено) и заканчивая `end` (равен buffer.length если не определено). Далее сравнивает полученый срез со значением находящимся в поле `bytes`. В случае если значения полностью совпадают - правило считается успешно соблюдённым.
- `notEqual` - обязательно содержит поле `bytes`. Получает срез буфера начиная со `start` (равен 0 если не определено) и заканчивая `end` (равен buffer.length если не определено). Далее сравнивает полученый срез со значением находящимся в поле `bytes`. В случае если значения не совпадают - правило считается успешно соблюдённым.
- `contains` - обязательно содержит поле `bytes`. Получает срез буфера начиная со `start` (равен 0 если не определено) и заканчивая `end` (равен buffer.length если не определено). Далее происходит попытка найти вхождение последовательности байт находящихся в поле `bytes` в полученном срезе. Если вхождение найдено - правило считается успешно соблюдённым.
- `notContains` - обязательно содержит поле `bytes`. Получает срез буфера начиная со `start` (равен 0 если не определено) и заканчивая `end` (равен buffer.length если не определено). Далее происходит попытка найти вхождение последовательности байт находящихся в поле `bytes` в полученном срезе. Если вхождение не найдено - правило считается успешно соблюдённым.

Далее рассмотрим типы `or` и `and`.

- `or` - 


